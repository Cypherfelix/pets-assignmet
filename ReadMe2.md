The Pet class is an abstract class. It must implement the Comparable interface so that you can sort a list of pets by their name. It should have data members for storing the name, age, and weight for the pet. It should also have int values for storing the animal’s food, attention, and sleep cutoffs. These cutoff values will be compared against randomly generated integers that will determine whether the Pet needs to eat, get attention, or sleep. To generate the random numbers, the Pet class should also have a Random object built into it. The is an example of ownership. Specifically, it is an example of Composition, since its constructors must build the Random number generator object.
The Pet class will include a function for representing the Pet as a String (toString). Of course, since it implements Comparable, the Pet class must also implement the compareTo function, like we did with Employee and Shape in class. It should also have an abstract function called getType that returns the type of the pet (dog, cat, or fish) that will be overridden in those subclasses. It will also have an abstract function for initializing the cutoff values. The subclasses (dog, cat, fish) will override that function to initialize the sleep, eat, and attention cutoffs to numbers that seem reasonable for that kind of pet. I recommend setting these numbers to between 0 and 24. That way, the number represents a probabilistic estimate of how many hours of the day the pet will eat, sleep, or seek attention.
The Pet class will have functions in it that will determine whether the pet needs food, is sleeping, or needs attention. These functions will return true or false. To decide what to return, the functions will generate a number and compare it with the corresponding cutoff (i.e. the sleep, eat, and attention cutoffs).
Finally, the Pet class will have an act() function. The act() function will return a String that explains everything the pet since the last time act() was called. The act() function will lean on its functions for determining if the pet needs to sleep, to eat, or to get attention to decide whether those activities should be mentioned in the multi-line String it returns. Subclasses like Dog, Cat, and Fish will override this to add on to these instinctual actions a Pet may take.
Each subclass – Dog, Cat, Fish – will override the initialize cutoffs function, act(), and getType(). In the initialize cutoffs function, a dog might set the cutoffs so that they don’t eat that often (maybe 3 hours of the day) but do seek attention often and sleep a lot. A cat or a fish would set different cutoff values in their initialize cutoffs function. In act(), all subclasses will start with the instinctual activities their base class – Pet – came up with in its act() function, but they will add onto it 0 or 1 other activities, depending on the result of asking its random number generator to generate another number. Based on that additional number, a dog, for example, might decide to play fetch or whimper, or a cat might decide to play with a ball of  yarn or jump onto a bookshelf. You should add whatever behavior options you think are germane to a particular kind of pet. The act() function for a dog, cat, or fish will add this custom activity (if there is one, depending on the outcome of the random number generator) to the instinctual ones prescribed by the superclass and return a multi-line string that contains it all.
Of course, each subclass should also override the getType() function to return its type – dog, cat, or fish.
PetWriter will leverage each class’s toString function to write Pet objects to the screen and to a file. PetReader will assume this format when reading a line at a time from the file to rebuild a list of pets.
The App class that has main() in it will print a welcome banner. It will then repeatedly ask the user what they want to do. If they choose to add a new pet, the App class will ask all the questions needed to add a new Pet to the list of pets. If the user wants to see a list of pets or write them to a file, the App class will lean on PetWriter to do so, like any good MVC application would. If they want to clear the list of pets, the program will do so simply by asking the ArrayList<Pet> we’ve been building to clear(). If the program wants to load a list of pets from the file, it will do so by leaning on PetReader. If the user wants to simulate a day in the life of their pets, the application will use a for loop that runs through hours 1 through 24. During each hour, the program will ask each pet in the ArrayList<Pet> to act() and print the String that function returns. Thanks to polymorphism, each Pet will activate its own act() function, which will generate a String that describes a set of activities that reflect that pet’s proclivities for sleeping, eating, and seeking attention as well as the custom activities that particular pet engages in.

